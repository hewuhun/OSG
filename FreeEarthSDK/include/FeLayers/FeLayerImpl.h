/**************************************************************************************************
* @file FeLayerImpl.h
* @note 图层通用接口实现模板
* @author g00034
* @data 2018-7-16
**************************************************************************************************/
#ifndef FE_LAYER_IMPL_H
#define FE_LAYER_IMPL_H

namespace FeLayers
{
	/**
	  * @class IFeLayerImpl
	  * @brief 图层通用接口实现模板类
	  * @author g00034
	*/
	template<class SuperParent, class LayerType>
	class IFeLayerImpl : public SuperParent
	{
	public:
		IFeLayerImpl(CFeLayerConfig& cfg):m_layerConfigRef(cfg){}

		/**
		*@note: 设置图层名称
		*/
		virtual void SetName(const std::string& strName)
		{
			m_layerConfigRef.name() = strName;
		}

		/**
		*@note: 获得图层名称
		*/
		virtual const std::string& GetName() const
		{
			return m_layerConfigRef.name().get();
		}

		/**
		*@note: 设置图层显隐状态
		*/
		virtual void SetVisible(bool bVisible)
		{
			m_layerConfigRef.visible() = bVisible;
			if(m_rpLayerEarth.valid()) m_rpLayerEarth->setVisible(bVisible);
		}

		/**
		*@note: 获取图层显隐状态
		*/
		virtual bool GetVisible() const 
		{
			return m_layerConfigRef.visible().get();
		}

		/**
		*@note: 获得图层ID
		*/
		virtual FeLayerID GetLayerUID()
		{
			return (m_rpLayerEarth.valid()) ? m_rpLayerEarth->getUID() : 0;
		}

		/**
		*@note: 获得图层属性配置
		*/
		virtual CFeLayerConfig GetLayerConfig()
		{
			return m_layerConfigRef;
		}

		/**
		*@note: 获得图层具体类型
		*/
		virtual LayerType* GetEarthLayer()
		{
			return (m_rpLayerEarth.valid()) ? m_rpLayerEarth.get() : NULL;
		}

	protected:
		osg::ref_ptr< LayerType > m_rpLayerEarth;
		CFeLayerConfig&           m_layerConfigRef;
	};

}


namespace FeLayers
{
	/**
	  * @class CTerrianLayerCache
	  * @brief osgEarth 地形图层缓存功能实现
	  * @note 为扩展osgEarth地形图层的缓存功能（考虑移植到osgEarth中）
	  * @author g00034
	*/
	template<class SuperParent, class LayerOptions>
	class CTerrianLayerCache : public SuperParent
	{
		typedef SuperParent SuperClass;
	public:
		 /**
         * Constructs a new image layer.
         */
        CTerrianLayerCache( const LayerOptions& options )
			: SuperClass(options)
			, m_bCacheChanged(false)
		{
			m_bEnableCache = true;
		}

		/** 
         * The cache bin for storing data generated by this layer
         */
        virtual osgEarth::CacheBin* getCacheBin( const osgEarth::Profile* profile )
		{
			if(!m_bEnableCache) return NULL;

			if(m_bCacheChanged) 
			{
				ResetCache();
			}

			return SuperClass::getCacheBin(profile);
		}

	public:
		/**
		*@note: 设置图层缓存路径
		*/
		void SetCachePath(const std::string& path)
		{
                        if(0 != SuperParent::_runtimeOptions.cachePath()->compare(path))
			{
                                SuperParent::_runtimeOptions.cachePath() = path;
				m_bCacheChanged = true;
			}
		}

		/**
		*@note: 设置缓存文件夹ID
		*/
		void SetCacheID(const std::string& cacheID)
		{
                        if(0 != SuperParent::_runtimeOptions.cacheId()->compare(cacheID))
			{
				// 修改了ID，在下次使用时，如果对应的缓存不存在，则会自动创建
                                SuperParent::_runtimeOptions.cacheId() = cacheID;
			}
		}

		/**
		*@note: 设置图层缓存使能状态
		*/
		void EnabelCache(bool bEnable){ m_bEnableCache = bEnable; }
		bool IsCacheEnable(){ return m_bEnableCache; }

	protected:
		/**
		*@note: 重置缓存，缓存状态变更后调用
		*/
		void ResetCache()
		{
			OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_mutexResetCache);

			if(m_bCacheChanged)
			{
				// 缓存路径变更，需要重置缓存，内部重新创建缓存对象
				SuperClass::ResetCache();
				m_bCacheChanged = false;
			}
		}

	private:
		// 标记缓存状态是否更改
		bool m_bCacheChanged;

		// 是否使用缓存
		bool m_bEnableCache;

		OpenThreads::Mutex m_mutexResetCache;
	};
}

#endif
